Примеры написания кода
========================================

Несколько примеров кода смарт-контрактов с комментариями для лучшего понимания механики работы RIDE.

Голосование
------------

Now there are many scam assets in our blockchain because we allow to create and transfer every asset if its creator pays a fee. Transfers are saved in blockchain and when the asset is a 
trash maybe we should protect our blockchain from it. It could be possible with the token curated registry - a registry of listings generated by token holders.

A holder stakes a portion of tokens to perform an action, i.e. adding a listing. Token holders can vote on whether to accept or reject the action using their tokens. 
A majority wins the vote and the action is accepted or rejected. The list is updated and should become more valuable given the improved listings and staked tokens are now out of circulation.

In our smart account implementation, we check that user can add assets by a key = asset_name only with count = 0 and only in adding or "challenge" period. 
Also, we check that user has the corresponding tokens on a balance. Then, in the voting period, users can vote to every asset they have, but only once for each one and only with an assessment from 1 to 10. Their votes are put with keys user_address+assetID.

.. important:: Поля транзакций можно использовать не по назначению, например в proofs можно класть любой байтовый объект, а не только подпись. И код контракта можно переписать потому что у нас есть поле author и нам не нужны эти костыли...

Пример кода контракта

.. code-block:: ruby
  :linenos:

    let asset = base58'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcNf' 
    # 
    let addingStartHeight = 1000	
    # Высота блокчейна после которой можно инициировать голования.	
    let votingStartHeight = 2000 	
    # Высота начала голосования.
    let votingEndHeight = 3000		
    # Высота окончания голосования.
    let this = extract(tx.sender)	
    # Переименование стандартной функции, извлекаем данные с адреса контракта (т.к. дальше будем работать с дата-транзакциями, которые отправляются от имени контракта).
    let address = addressFromPublicKey(tx.proofs[1]) 
    # Определяем переменную address(адрес участника голосования), нативной функцией addressFromPublicKey из ключа, вложенного в массив proofs транзакции.
    match tx {
        # Указание на pattern matching, обязательно, если контракт проверяет условия транзакций.
        case t: DataTransaction => 	
        # Определяем тип валидируемой транзакции, case %←имя объекта «транзакция», по которому в дальнейшем можно обратиться к ней.
            if(height > addingStartHeight)	
            # Условие на сравнение текущей высоты блокчейна нативной функцией height с ранее объявленной константой.
            then(
            # Если высота больше высоты начала добавления кандидатов на голосование, тогда переходим к следующей проверке, иначе контракт возвращает false и отклоняет транзакцию.   
                if(height < votingStartHeight)
                 # Если высота меньше высоты старта голосования, тогда переходим к следующей проверке.
                then(
                    # Тогда пробуем добавить токен в лист голосования (если проверки ниже вернут true, тогда на адрес контракта будут записаны данные с ключом идентификатор_набора_токенов и его значением 0). 
                    let hasTokens = assetBalance(address, asset) > 0
                    # Определяем переменную (проверка баланса голосующего) передавая булево значение результата сравнения с нулем баланса голосующего по заданному в контракте набору токенов, полученному нативной функцией assetBalance.
                    size(t.data) == 1 && !isDefined(getInteger(this, toBase58String(asset))) && extract(getInteger(t.data, toBase58String(asset))) == 0 && hasToken
                    # Обращаемся к транзакции конструкцией имя_транзакции.имя_поля и проверяем что в поле data у нас 1 пара ключ-значение И на адресе контракта по ключу идентификатор_набора_токенов нет числовых 
                    # значений (нативной функцией isDefined с отрицанием !) И в транзакции по ключу идентификатор_набора_токенов задано значение = 0 И проверка баланса голосующего вернула true.   
                )
                else(
                    # Иначе, проверяем что голосование ещё не закончилось, также сравнением текущей высоты блокчейна с высотой окончания голосования.			
                    if(height < votingEndHeight)	
                    # Если голосование не закончено, тогда переходим к проверке транзакции на соответствие условиям голосования.
                    then
                    (   
                        # голосование
                        let currentAmount = if(isDefined(getInteger(this, asset))) then  extract(getInteger(this, asset) else 0 
                        # Определяем текущее количество голосов: проверяем что если адресе контракта  владеет ассетом, тогда извлекаем баланс отправителя по ассету, иначе текущий баланс 0.
                        let newAmount = extract(getInteger(d.data, asset)) 	# Извлекаем новое значение баланса из дата транзакции по ID ассета
                        let betString = address + asset			          # Определяем вес голоса конкатенацией адреса и ассета (сейчас это 2 константы
                        let noBetBefore = !isDefined(getInteger(this, betString)) 	# Не определено значение веса голоса в стейте отправителя
                        let isBetCorrect = extract(getInteger(t.data, betString)) > 0 && extract(getInteger(d.data, betString)) <= 10 # Проверяем что вес голоса в диапазоне от 1 до 10.
                        let hasTokens = assetBalance(Bob, asset) > 0 		# Проверяем что баланс токена у голосущего больше 0
                        size(t.data) == 2 && isDefined(getInteger(this, asset)) && newAmount == currentAmount + 1 # Проверяем, что размер дата транзакции 2 поля, что у отправителя есть ассет, новое значение баланса = текущее+1.
                            && noBetBefore && isBetCorrect && hasTokens #
                        # голосование
                        let currentAmount = extract(getInteger(this, toBase58String(asset)))
                        # Определяем текущее количество голосов: извлекаем с адреса контракта числовое значение по ключу идентификатор_набора_токенов.
                        let newAmount = extract(getInteger(t.data, toBase58String(asset)))
                        # Определяем обновленное количество голосов: извлекаем из транзакции числовое значение по ключу идентификатор_набора_токенов.
                        let betString = toBase58String(address.bytes) + toBase58String(asset)
                        # Определяем идентификатор голоса конкатенацией адреса голосующего и идентификатора_набора_токенов
                        let noBetBefore = !isDefined(getInteger(this, betString))
                        # Проверяем что идентификатора голоса не определен ранее на адресе контракта.
                        let isBetCorrect = extract(getInteger(t.data, betString)) > 0 && extract(getInteger(t.data, betString)) <= 10
                        # Проверяем что что оценка находится в допустимом диапазоне, извлекая из транзакции значение по ключу идентификатор_голоса и проверя его попадание в диапазон от 1 до 10.
                        let hasTokens = assetBalance(address, asset) > 0
                        # Определяем переменную (проверка баланса голосующего) передавая булево значение результата сравнения с нулем баланса голосующего по заданному в контракте набору токенов, полученному нативной функцией assetBalance.
                        size(t.data) == 2 && isDefined(getInteger(this, toBase58String(asset))) && newAmount == currentAmount + 1
                            && noBetBefore && isBetCorrect && hasTokens
                        # Проверяем что в транзакции у нас 2 пары ключ-значение И на адресе контракта определен идентификатор_набора_токенов И обновленное количество голосов на 1 больше текущего 
                        # И пользователь не голосовал ранее И оценка корректна И проверка баланса вернула true
                )
                     ) 
                    else false          
                ) && sigVerify(tx.bodyBytes, tx.proofs[0])
                # Проверяем подпись транзакции нативной функцией sigVerify находящуюся на 0 позиции в массиве proofs
            )
            else false         
    case _ => false
    # Любые другие типы транзакций запрещены
    }